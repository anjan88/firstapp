<!DOCTYPE html>
<html lang="en" class="no-js">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Circular Navigation</title>
		<meta name="description" content="Circular Navigation Styles - Building a Circular Navigation with CSS Transforms | Codrops " />
		<meta name="keywords" content="css transforms, circular navigation, round navigation, circular menu, tutorial" />
		<meta name="author" content="Sara Soueidan for Codrops" />
		<link rel="shortcut icon" href="../favicon.ico">
		<link rel="stylesheet" type="text/css" href="../static/css/normalize.css" />
		<link rel="stylesheet" type="text/css" href="../static/css/demo.css" />
		<link rel="stylesheet" type="text/css" href="../static/css/component2.css" />
		<script src="../static/js/modernizr-2.6.2.min.js"></script>



	</head>
	<body>
		<div class="container">
			<!-- Top Navigation -->
			<div class="codrops-top clearfix">
				<a class="codrops-icon codrops-icon-prev" href="http://localhost:63342/webproject/templates/index.html"><span>Previous</span></a>
				<span class="right"><a class="codrops-icon codrops-icon-drop" href="http://localhost:63342/webproject/templates/index.html"><span>Home</span></a></span>
			</div>
			<header>
				<h1>Circular Navigation <span>Building a Circular Navigation with a Django Framework</span></h1>
				<nav class="codrops-demos">
					<a href="index.html">Django Instructions</a>
					<a class="current-demo" href="index2.html">Click & Discover</a>
					<a href="interactivedemo/index.html">Intractive demo</a>
				</nav>
			</header>
			<div class="component">
				<h2>Celery swiss chard melon</h2>
				<!-- Start Nav Structure -->
				<button class="cn-button" id="cn-button">Menu</button>
				<div class="cn-wrapper" id="cn-wrapper">
					<ul>
						<li><a href="http://127.0.0.1:8000/connection2/"><span>ADD</span></a></li>
						<li><a href="http://127.0.0.1:8000/connection3/"><span>Login</span></a></li>
						<li><a href="http://127.0.0.1:8000/formpage/"><span>Form</span></a></li>
						<li><a href="http://127.0.0.1:8000/connection4/"><span>Multiply</span></a></li>
						<li><a href="http://127.0.0.1:8000/getemployees/"><span>Resultset</span></a></li>
						<li><a href="http://127.0.0.1:8000/home/"><span>Upload</span></a></li>
						<li><a href="http://127.0.0.1:8000/mail/"><span>Contact</span></a></li>
					 </ul>
				</div>
				<!-- End of Nav Structure -->
            </div>
			<section>
                <p>MySQL notes Version support</p>
                Django supports MySQL 5.0.3 and higher.</p>
                <p>MySQL 5.0 adds the information_schema database, which contains detailed data on all database schema.
                    Django’s inspectdb feature uses it.</p>
                Changed in version 1.5: The minimum version requirement of MySQL 5.0.3
                was set in Django 1.5.</p>
                <p>Django expects the database to support Unicode (UTF-8 encoding) and delegates to it the task
                   of enforcing transactions and referential integrity. It is important to be aware of the fact that the two latter ones aren’t
                    actually enforced by MySQL when using the MyISAM storage engine, see the next section.</p>
                Storage engines</p>
                <p>MySQL has several storage engines (previously called table types). You can change the default storage engine in the
                    server configuration.</p>
                <p>Until MySQL 5.5.4, the default engine was MyISAM 34. The main drawbacks of MyISAM are that it doesn’t support
                    transactions or enforce foreign-key constraints. On the plus side, it’s currently the only engine that supports full-text
                    indexing and searching.</p>
                <p>Since MySQL 5.5.5, the default storage engine is InnoDB. This engine is fully transactional and supports foreign
                    key references. It’s probably the best choice at this point.</p>
                    Changed in version 1.4: Please see the release notes In</p>
                <p>previous versions of Django, fixtures with forward references (i.e. relations to rows that have not yet been inserted
                   into the database) would fail to load when using the InnoDB storage engine. This was due to the fact that InnoDB
                    deviates from the SQL standard by checking foreign key constraints immediately instead of deferring the check until
                    the transaction is committed. This problem has been resolved in Django 1.4. Fixture data is now loaded with foreign
                    key checks turned off; foreign key checks are then re-enabled when the data has finished loading, at which point the
                    entire table is checked for invalid foreign key references and an IntegrityError is raised if any are found.</p>
                MySQLdb</p>
                MySQLdb is the Python interface to MySQL. Version 1.2.1p2 or later is required for full MySQL support in Django.</p>
                <p>Note: If you see ImportError: cannot import name ImmutableSet when trying to use Django, your
                    MySQLdb installation may contain an outdated sets.py file that conflicts with the built-in module of the same name
                    from Python 2.4 and later. To fix this, verify that you have installed MySQLdb version 1.2.1p2 or newer, then delete
                    the sets.py file in the MySQLdb directory that was left by an earlier version.</p>
            Creating your database</p>
            <p>You can create your database using the command-line tools and this SQL:
                CREATE DATABASE dbname CHARACTER SET utf8;
                This ensures all tables and columns will use UTF-8 by default.
                34 Unless this was changed by the packager of your MySQL package. We’ve had reports that the Windows Community Server installer sets up
                    InnoDB as the default storage engine, for example.</p>
            API ReferenceDjango Documentation, Release 1.5</p>
            Collation settings</p>
            <p>The collation setting for a column controls the order in which data is sorted as well as what strings compare as equal. It
                can be set on a database-wide level and also per-table and per-column. This is documented thoroughly in the MySQL
                documentation. In all cases, you set the collation by directly manipulating the database tables; Django doesn’t provide
                a way to set this on the model definition.</p>
            <p>By default, with a UTF-8 database, MySQL will use the utf8_general_ci_swedish collation. This results in
               all string equality comparisons being done in a case-insensitive manner. That is, "Fred" and "freD" are considered
               equal at the database level. If you have a unique constraint on a field, it would be illegal to try to insert both "aa" and
               "AA" into the same column, since they compare as equal (and, hence, non-unique) with the default collation.
               In many cases, this default will not be a problem. However, if you really want case-sensitive comparisons on a
               particular column or table, you would change the column or table to use the utf8_bin collation. The main
               thing to be aware of in this case is that if you are using MySQLdb 1.2.2, the database backend in Django will
               then return bytestrings (instead of unicode strings) for any character fields it receive from the database. This is
               a strong variation from Django’s normal practice of always returning unicode strings. It is up to you, the developer,
                to handle the fact that you will receive bytestrings if you configure your table(s) to use utf8_bin collation.</p>
             <p>Django itself should mostly work smoothly with such columns (except for the contrib.sessions
               Session and contrib.admin LogEntry tables described below), but your code must be prepared to call
               django.utils.encoding.smart_unicode() at times if it really wants to work with consistent data –
               Django will not do this for you (the database backend layer and the model population layer are separated internally so
               the database layer doesn’t know it needs to make this conversion in this one particular case).
               If you’re using MySQLdb 1.2.1p2, Django’s standard CharField class will return unicode strings even with
               utf8_bin collation. However, TextField fields will be returned as an array.array instance (from Python’s
               standard array module). There isn’t a lot Django can do about that, since, again, the information needed to make the
               necessary conversions isn’t available when the data is read in from the database. This problem was fixed in MySQLdb
               1.2.2, so if you want to use TextField with utf8_bin collation, upgrading to version 1.2.2 and then dealing with
                 the bytestrings (which shouldn’t be too difficult) as described above is the recommended solution.</p>
            <p>Should you decide to use utf8_bin collation for some of your tables with MySQLdb 1.2.1p2
               or 1.2.2, you should still use utf8_collation_ci_swedish (the default) collation for the
               django.contrib.sessions.models.Session table (usually called django_session) and the
               django.contrib.admin.models.LogEntry table (usually called django_admin_log). Those are the
                two standard tables that use TextField internally.</p>
            Connecting to the database</p>
            <p>Refer to the settings documentation.</p>
            <p>Connection settings are used in this order:
               1. OPTIONS.
               2. NAME, USER, PASSWORD, HOST, PORT
               3. MySQL option files.
               In other words, if you set the name of the database in OPTIONS, this will take precedence over NAME, which would
                override anything in a MySQL option file.</p>
           <p> Here’s a sample configuration which uses a MySQL option file:
               # settings.py
               DATABASES = {
               ’default’: {
               ’ENGINE’: ’django.db.backends.mysql’,
               6.4. Databases 677Django Documentation, Release 1.5
               ’OPTIONS’: {
               ’read_default_file’: ’/path/to/my.cnf’,
               },
               }
               }
               # my.cnf
               [client]
               database = NAME
               user = USER
               password = PASSWORD
               default-character-set = utf8
               Several other MySQLdb connection options may be useful, such as ssl, use_unicode, init_command, and
               sql_mode. Consult the MySQLdb documentation for more details.</p>
            </section>
		</div><!-- /container -->
		<script src="../static/js/polyfills.js"></script>
		<script src="../static/js/demo2.js"></script>
	</body>
</html>